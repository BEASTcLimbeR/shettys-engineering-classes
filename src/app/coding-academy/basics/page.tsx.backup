"use client";

import React, { useState, useEffect } from 'react';
import { Box, Typography, Container, Paper, AppBar, Toolbar, Button, Grid, Chip, IconButton, Tabs, Tab } from '@mui/material';
import { motion, AnimatePresence } from 'framer-motion';
import { useRouter } from 'next/navigation';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import CodeIcon from '@mui/icons-material/Code';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import MemoryIcon from '@mui/icons-material/Memory';
import SchoolIcon from '@mui/icons-material/School';
import StopIcon from '@mui/icons-material/Stop';
import PsychologyIcon from '@mui/icons-material/Psychology';
import DataObjectIcon from '@mui/icons-material/DataObject';
import CoffeeIcon from '@mui/icons-material/Coffee';
import WhatsAppIcon from '@mui/icons-material/WhatsApp';
import Loader from '../../../components/Loader';
import programersWorking from '../../../../public/programers-working.json';

const BasicsPage: React.FC = () => {
  const router = useRouter();
  const [copiedIndex, setCopiedIndex] = useState<number | null>(null);
  const [activeTab, setActiveTab] = useState(0);
  const [runningCode, setRunningCode] = useState<number | null>(null);
  const [codeOutputs, setCodeOutputs] = useState<{ [key: number]: string }>({});
  const [userInputs, setUserInputs] = useState<{ [key: number]: string[] }>({});
  const [showInputPrompt, setShowInputPrompt] = useState<number | null>(null);
  const [currentInputIndex, setCurrentInputIndex] = useState(0);
  const [inputValues, setInputValues] = useState<string[]>([]);
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    // Custom preloader for basics page
    const timer = setTimeout(() => {
      setIsLoaded(true);
    }, 2000); // 2 seconds for programming-themed preloader
    
    return () => clearTimeout(timer);
  }, []);

  // Simulated code execution outputs with user input support
  const getCodeOutput = (code: string, language: string, inputs: string[] = []): string => {
    if (language === 'C') {
      if (code.includes('printf("Hello, World!")')) {
        return "Hello, World!";
      } else if (code.includes('printf("Age: %d")')) {
        return "Age: 25\nSalary: 50000.50\nGrade: A\nPi: 3.14159";
      } else if (code.includes('printf("Adult")')) {
        const age = inputs[0] || "18";
        const ageNum = parseInt(age);
        if (ageNum >= 18) {
          return `Age: ${age}\nAdult\n0 1 2 3 4 5 6 7 8 9\nCount: 0\nCount: 1\nCount: 2\nCount: 3\nCount: 4`;
        } else {
          return `Age: ${age}\nMinor\n0 1 2 3 4 5 6 7 8 9\nCount: 0\nCount: 1\nCount: 2\nCount: 3\nCount: 4`;
        }
      } else if (code.includes('int add(int a, int b)')) {
        const a = inputs[0] || "5";
        const b = inputs[1] || "3";
        const sum = parseInt(a) + parseInt(b);
        return `Sum: ${sum}\nHello, Student!`;
      } else if (code.includes('printf("First element: %d")')) {
        return "First element: 1\nLast element: 5\nnumbers[0] = 1\nnumbers[1] = 2\nnumbers[2] = 3\nnumbers[3] = 4\nnumbers[4] = 5";
      } else if (code.includes('printf("Value: %d")')) {
        const value = inputs[0] || "42";
        const newValue = inputs[1] || "100";
        return `Value: ${value}\nAddress: 0x7fff5fbff8c8\nPointer value: ${value}\nNew value: ${newValue}`;
      }
    } else if (language === 'C++') {
      if (code.includes('cout << "Hello, World!"')) {
        return "Hello, World!";
      } else if (code.includes('class Student')) {
        const name = inputs[0] || "John";
        const age = inputs[1] || "20";
        return `Name: ${name}, Age: ${age}`;
      } else if (code.includes('class Person')) {
        const name = inputs[0] || "John";
        const roll = inputs[1] || "101";
        return `Student: ${name}, Roll: ${roll}`;
      } else if (code.includes('class Shape')) {
        return "Drawing Circle\nDrawing Rectangle";
      } else if (code.includes('template <typename T>')) {
        const a = inputs[0] || "5";
        const b = inputs[1] || "3";
        const sum = parseInt(a) + parseInt(b);
        return `Template result: ${sum}\nTemplate function and class created successfully`;
      } else if (code.includes('vector<int> numbers')) {
        const size = inputs[0] || "5";
        return `Vector size: ${size}\n1 3 4 5\nAlice: 95\nBob: 87`;
      }
    } else if (language === 'DSA') {
      if (code.includes('cout << "Array element:"')) {
        const index = inputs[0] || "2";
        const element = parseInt(index) + 1;
        return `Array element: ${element}`;
      } else if (code.includes('vector<int> dynamicArray')) {
        const element = inputs[0] || "6";
        return `Added element: ${element}\nVector operations completed successfully`;
      } else if (code.includes('class LinkedList')) {
        const data = inputs[0] || "42";
        return `Inserted node with data: ${data}\nLinked list node inserted successfully`;
      } else if (code.includes('stack<int> s')) {
        const pushValue = inputs[0] || "30";
        return `Pushed: ${pushValue}\nStack top: 20\nQueue front: 10`;
      } else if (code.includes('class BinaryTree')) {
        const data = inputs[0] || "15";
        return `Inserted node: ${data}\nBinary tree node inserted successfully`;
      } else if (code.includes('class Graph')) {
        const start = inputs[0] || "0";
        return `BFS starting from vertex: ${start}\n0 1 2 3 4`;
      }
    } else if (language === 'Python') {
      if (code.includes('print("Hello, World!")')) {
        return "Hello, World!";
      } else if (code.includes('def greet(name):')) {
        const name = inputs[0] || "Bob";
        return `Hello, ${name}!`;
      } else if (code.includes('class Person:')) {
        const name = inputs[0] || "Alice";
        const age = inputs[1] || "25";
        return `Name: ${name}, Age: ${age}`;
      } else if (code.includes('my_list = [')) {
        const element = inputs[0] || "6";
        return `List: [1, 2, 3, 4, 5, ${element}]\nDictionary: {'name': 'Alice', 'age': 25, 'city': 'New York'}\nSet: {1, 2, 4, 5, 6}\nTuple: (1, 2, 3)`;
      } else if (code.includes('import numpy')) {
        return "Linear regression model trained successfully!\nPrediction: 12.0\nModel accuracy: 95.2%";
      }
    } else if (language === 'ML') {
      if (code.includes('LinearRegression()')) {
        return "Linear regression model trained successfully!\nPrediction: 12.0\nModel accuracy: 95.2%";
      } else if (code.includes('KMeans(')) {
        return "K-Means clustering completed!\nCluster centers: [[1.0, 2.0], [4.0, 2.0]]\nNumber of clusters: 2";
      } else if (code.includes('Sequential()')) {
        return "Neural network trained successfully!\nTraining accuracy: 92.5%\nTest accuracy: 90.0%";
      } else if (code.includes('make_classification')) {
        return "Classification dataset generated!\nFeatures: 2\nSamples: 100\nClasses: 2";
      }
    } else if (language === 'Java') {
      if (code.includes('System.out.println("Hello, World!")')) {
        return "Hello, World!";
      } else if (code.includes('System.out.println("Age: " + age)')) {
        return "Age: 25\nSalary: 50000.5\nGrade: A\nPi: 3.14159";
      } else if (code.includes('System.out.println("Adult")')) {
        const age = inputs[0] || "20";
        const ageNum = parseInt(age);
        if (ageNum >= 18) {
          return `Age: ${age}\nAdult\n0 1 2 3 4 5 6 7 8 9\nCount: 0\nCount: 1\nCount: 2\nCount: 3\nCount: 4`;
        } else {
          return `Age: ${age}\nMinor\n0 1 2 3 4 5 6 7 8 9\nCount: 0\nCount: 1\nCount: 2\nCount: 3\nCount: 4`;
        }
      } else if (code.includes('public static int add(int a, int b)')) {
        const a = inputs[0] || "5";
        const b = inputs[1] || "3";
        const sum = parseInt(a) + parseInt(b);
        return `Sum: ${sum}\nHello, Student!`;
      } else if (code.includes('System.out.println("First element: " + numbers[0])')) {
        return "First element: 1\nLast element: 5\nnumbers[0] = 1\nnumbers[1] = 2\nnumbers[2] = 3\nnumbers[3] = 4\nnumbers[4] = 5";
      } else if (code.includes('System.out.println("Value: " + number)')) {
        const value = inputs[0] || "42";
        const newValue = inputs[1] || "100";
        return `Value: ${value}\nAddress: 0x7fff5fbff8c8\nPointer value: ${value}\nNew value: ${newValue}`;
      }
    } else if (language === 'DSA_Python') {
      if (code.includes('def linear_search(arr, target)') && !code.includes('binary_search')) {
        const target = inputs[0] || "7";
        return `Element ${target} found at index: 3\nFunction linear_search took 0.000123 seconds`;
      } else if (code.includes('numbers.append(6)')) {
        return "Original list: [1, 2, 3, 4, 5]\nAfter adding elements: [0, 1, 2, 3, 4, 5, 6]\nAfter removing elements: [0, 1, 4, 5]\nPopped element: 5\nSquares: [1, 4, 9, 16, 25]\nInteger array: array('i', [1, 2, 3, 4, 5])";
      } else if (code.includes('class Stack:')) {
        return "Stack: [1, 2, 3]\nPopped: 3\nQueue: ['A', 'B', 'C']\nDequeued: A";
      } else if (code.includes('class LinkedList:')) {
        const data = inputs[0] || "2";
        return `Linked List: 0 -> 1 -> 2 -> 3\nSearch 2 at position: 2\nAfter deleting 2: 0 -> 1 -> 3`;
      } else if (code.includes('class BinaryTree:')) {
        const data = inputs[0] || "3";
        return "Inorder traversal: 1 3 5 7 9\nPreorder traversal: 5 3 1 7 9\nPostorder traversal: 1 3 9 7 5\nFound node with data: 3";
      } else if (code.includes('class Graph:')) {
        const start = inputs[0] || "2";
        return `BFS starting from vertex 2:\n[2, 0, 3, 1]\nDFS starting from vertex 2:\n[2, 0, 1, 3]\nGraph has cycle: True`;
      } else if (code.includes('def bubble_sort(arr)')) {
        return "Original array: [64, 34, 25, 12, 22, 11, 90]\nBubble Sort: [11, 12, 22, 25, 34, 64, 90] (Time: 0.000045s)\nSelection Sort: [11, 12, 22, 25, 34, 64, 90] (Time: 0.000032s)\nInsertion Sort: [11, 12, 22, 25, 34, 64, 90] (Time: 0.000028s)\nMerge Sort: [11, 12, 22, 25, 34, 64, 90] (Time: 0.000015s)\nQuick Sort: [11, 12, 22, 25, 34, 64, 90] (Time: 0.000012s)";
      } else if (code.includes('def linear_search(arr, target)') && code.includes('binary_search')) {
        const target = inputs[0] || "10";
        return `Array: [2, 3, 4, 10, 40, 50, 60, 70, 80, 90, 100]\nSearching for: ${target}\nLinear Search: Found at index 3 (Time: 0.000008s)\nBinary Search: Found at index 3 (Time: 0.000002s)\nBinary Search (Recursive): Found at index 3 (Time: 0.000003s)\nJump Search: Found at index 3 (Time: 0.000005s)`;
      } else if (code.includes('def fibonacci_memo')) {
        return "Fibonacci with memoization:\nF(0) = 0\nF(1) = 1\nF(2) = 1\nF(3) = 2\nF(4) = 3\nF(5) = 5\nF(6) = 8\nF(7) = 13\nF(8) = 21\nF(9) = 34\n\nFibonacci with tabulation:\nF(0) = 0\nF(1) = 1\nF(2) = 1\nF(3) = 2\nF(4) = 3\nF(5) = 5\nF(6) = 8\nF(7) = 13\nF(8) = 21\nF(9) = 34\n\nLongest Common Subsequence:\nLCS of 'ABCDGH' and 'AEDFHR': 3\n\nKnapsack Problem:\nMaximum value: 37";
      }
    }
    
    // More specific fallback outputs based on code content
    if (code.includes('printf')) {
      return "Program output displayed successfully";
    } else if (code.includes('cout')) {
      return "C++ program executed successfully";
    } else if (code.includes('class')) {
      return "Class definition created successfully";
    } else if (code.includes('struct')) {
      return "Structure defined successfully";
    } else if (code.includes('template')) {
      return "Template instantiated successfully";
    } else if (code.includes('vector') || code.includes('stack') || code.includes('queue')) {
      return "Data structure operations completed";
    } else if (code.includes('for') || code.includes('while')) {
      return "Loop executed successfully";
    } else if (code.includes('if') || code.includes('else')) {
      return "Conditional statement executed";
    } else if (code.includes('function') || code.includes('void') || code.includes('int')) {
      return "Function executed successfully";
    } else {
      return "Program compiled and executed successfully!";
    }
  };

  // Get required inputs for a specific code
  const getRequiredInputs = (code: string, language: string): string[] => {
    if (language === 'C') {
      if (code.includes('printf("Adult")')) {
        return ["Enter age: "];
      } else if (code.includes('int add(int a, int b)')) {
        return ["Enter first number: ", "Enter second number: "];
      } else if (code.includes('printf("Value: %d")')) {
        return ["Enter initial value: ", "Enter new value: "];
      }
    } else if (language === 'C++') {
      if (code.includes('class Student')) {
        return ["Enter student name: ", "Enter student age: "];
      } else if (code.includes('class Person')) {
        return ["Enter student name: ", "Enter roll number: "];
      } else if (code.includes('template <typename T>')) {
        return ["Enter first number: ", "Enter second number: "];
      } else if (code.includes('vector<int> numbers')) {
        return ["Enter vector size: "];
      }
    } else if (language === 'DSA') {
      if (code.includes('cout << "Array element:"')) {
        return ["Enter array index: "];
      } else if (code.includes('vector<int> dynamicArray')) {
        return ["Enter element to add: "];
      } else if (code.includes('class LinkedList')) {
        return ["Enter data for new node: "];
      } else if (code.includes('stack<int> s')) {
        return ["Enter value to push: "];
      } else if (code.includes('class BinaryTree')) {
        return ["Enter data for new node: "];
      } else if (code.includes('class Graph')) {
        return ["Enter starting vertex: "];
      }
    } else if (language === 'Python') {
      if (code.includes('def greet(name):')) {
        return ["Enter name: "];
      } else if (code.includes('class Person:')) {
        return ["Enter person name: ", "Enter person age: "];
      } else if (code.includes('my_list = [')) {
        return ["Enter element to add: "];
      } else if (code.includes('import numpy')) {
        return ["Enter number of samples: "];
      }
    } else if (language === 'ML') {
      if (code.includes('LinearRegression()')) {
        return ["Enter number of features: "];
      } else if (code.includes('KMeans(')) {
        return ["Enter number of clusters: "];
      } else if (code.includes('Sequential()')) {
        return ["Enter number of layers: "];
      } else if (code.includes('make_classification')) {
        return ["Enter number of samples: "];
      }
    } else if (language === 'Java') {
      if (code.includes('System.out.println("Adult")')) {
        return ["Enter age: "];
      } else if (code.includes('public static int add(int a, int b)')) {
        return ["Enter first number: ", "Enter second number: "];
      } else if (code.includes('System.out.println("Value: " + number)')) {
        return ["Enter initial value: ", "Enter new value: "];
      }
    } else if (language === 'DSA_Python') {
      if (code.includes('def linear_search(arr, target)') && !code.includes('binary_search')) {
        return ["Enter target element: "];
      } else if (code.includes('class LinkedList:')) {
        return ["Enter data for new node: "];
      } else if (code.includes('class BinaryTree:')) {
        return ["Enter data for new node: "];
      } else if (code.includes('class Graph:')) {
        return ["Enter starting vertex: "];
      } else if (code.includes('def linear_search(arr, target)') && code.includes('binary_search')) {
        return ["Enter target element: "];
      }
    }
    return [];
  };

  const runCode = async (index: number, code: string, language: string) => {
    const requiredInputs = getRequiredInputs(code, language);
    
    if (requiredInputs.length > 0) {
      // Show input prompts
      setShowInputPrompt(index);
      setCurrentInputIndex(0);
      setInputValues([]);
      setUserInputs(prev => ({ ...prev, [index]: requiredInputs }));
    } else {
      // No inputs needed, run directly
      setRunningCode(index);
      await new Promise(resolve => setTimeout(resolve, 1500));
      const output = getCodeOutput(code, language);
      setCodeOutputs(prev => ({ ...prev, [index]: output }));
      setRunningCode(null);
    }
  };

  const handleInputSubmit = async (index: number, code: string, language: string) => {
    const requiredInputs = getRequiredInputs(code, language);
    
    if (currentInputIndex < requiredInputs.length - 1) {
      // More inputs needed
      setCurrentInputIndex(prev => prev + 1);
    } else {
      // All inputs collected, run the code
      setShowInputPrompt(null);
      setRunningCode(index);
      await new Promise(resolve => setTimeout(resolve, 1500));
      const output = getCodeOutput(code, language, inputValues);
      setCodeOutputs(prev => ({ ...prev, [index]: output }));
      setRunningCode(null);
      setInputValues([]);
    }
  };

  const handleInputChange = (value: string) => {
    setInputValues(prev => {
      const newValues = [...prev];
      newValues[currentInputIndex] = value;
      return newValues;
    });
  };

  const stopCode = (index: number) => {
    setRunningCode(null);
    setShowInputPrompt(null);
    setCodeOutputs(prev => {
      const newOutputs = { ...prev };
      delete newOutputs[index];
      return newOutputs;
    });
    setInputValues([]);
  };

  const cTopics = [
    {
      title: "Introduction to C Programming",
      description: "Learn the fundamentals of C programming language",
      icon: "üî§",
      difficulty: "Beginner",
      definition: "C is a general-purpose, procedural programming language developed by Dennis Ritchie in 1972. It is a low-level language that provides direct access to memory and hardware, making it efficient for system programming.",
      keyConcepts: ["Procedural Programming", "Low-level Memory Access", "Portability", "Efficiency"],
      code: `#include <stdio.h>

int main() {
    printf("Hello, World!");
    return 0;
}`,
      explanation: "This is the basic structure of a C program. The #include directive includes the standard input/output library, and main() is the entry point of the program."
    },
    {
      title: "Variables and Data Types",
      description: "Understanding different data types in C",
      icon: "üìä",
      difficulty: "Beginner",
      definition: "Variables are named memory locations that store data values. Data types define the type and size of data that can be stored in variables.",
      keyConcepts: ["Memory Allocation", "Type Safety", "Size Specifications", "Value Storage"],
      code: `int age = 25;
float salary = 50000.50;
char grade = 'A';
double pi = 3.14159;

printf("Age: %d\\n", age);
printf("Salary: %.2f\\n", salary);
printf("Grade: %c\\n", grade);
printf("Pi: %.5f\\n", pi);`,
      explanation: "C supports various data types: int for integers, float for decimals, char for characters, and double for high-precision decimals."
    },
    {
      title: "Control Structures",
      description: "Mastering loops and conditional statements",
      icon: "üîÑ",
      difficulty: "Intermediate",
      definition: "Control structures are programming constructs that determine the flow of program execution based on conditions and loops.",
      keyConcepts: ["Conditional Logic", "Loop Control", "Flow Control", "Decision Making"],
      code: `// If-else statement
if (age >= 18) {
    printf("Adult\\n");
} else {
    printf("Minor\\n");
}

// For loop
for (int i = 0; i < 10; i++) {
    printf("%d ", i);
}

// While loop
int count = 0;
while (count < 5) {
    printf("Count: %d\\n", count);
    count++;
}`,
      explanation: "Control structures allow you to make decisions and repeat code blocks. Use if-else for conditions, for/while for loops."
    },
    {
      title: "Functions",
      description: "Creating reusable code blocks",
      icon: "‚öôÔ∏è",
      difficulty: "Intermediate",
      definition: "Functions are self-contained blocks of code that perform specific tasks. They promote code reusability and modularity.",
      keyConcepts: ["Code Reusability", "Modularity", "Parameter Passing", "Return Values"],
      code: `// Function declaration
int add(int a, int b) {
    return a + b;
}

// Function with void return type
void greet(char name[]) {
    printf("Hello, %s!\\n", name);
}

int main() {
    int result = add(5, 3);
    printf("Sum: %d\\n", result);
    
    greet("Student");
    return 0;
}`,
      explanation: "Functions help organize code into reusable blocks. They can return values or perform actions without returning anything (void)."
    },
    {
      title: "Arrays",
      description: "Working with collections of data",
      icon: "üì¶",
      difficulty: "Intermediate",
      definition: "Arrays are collections of elements of the same data type stored in contiguous memory locations.",
      keyConcepts: ["Contiguous Memory", "Index-based Access", "Fixed Size", "Homogeneous Data"],
      code: `// Array declaration and initialization
int numbers[5] = {1, 2, 3, 4, 5};

// Accessing array elements
printf("First element: %d\\n", numbers[0]);
printf("Last element: %d\\n", numbers[4]);

// Looping through array
for (int i = 0; i < 5; i++) {
    printf("numbers[%d] = %d\\n", i, numbers[i]);
}`,
      explanation: "Arrays store multiple values of the same type. Elements are accessed using index numbers starting from 0."
    },
    {
      title: "Pointers",
      description: "Understanding memory addresses",
      icon: "üìç",
      difficulty: "Advanced",
      definition: "Pointers are variables that store memory addresses of other variables. They provide direct access to memory locations.",
      keyConcepts: ["Memory Addresses", "Indirect Access", "Dynamic Memory", "Address Arithmetic"],
      code: `int number = 42;
int *ptr = &number;  // Pointer to number

printf("Value: %d\\n", number);
printf("Address: %p\\n", (void*)&number);
printf("Pointer value: %d\\n", *ptr);

// Modifying value through pointer
*ptr = 100;
printf("New value: %d\\n", number);`,
      explanation: "Pointers store memory addresses. They allow direct manipulation of memory and are fundamental to C programming."
    }
  ];

  const cppTopics = [
    {
      title: "Introduction to C++",
      description: "Learn object-oriented programming with C++",
      icon: "‚ö°",
      difficulty: "Beginner",
      definition: "C++ is an extension of C that adds object-oriented programming features. It combines procedural and object-oriented programming paradigms.",
      keyConcepts: ["Object-Oriented Programming", "Encapsulation", "Inheritance", "Polymorphism"],
      code: `#include <iostream>
using namespace std;

int main() {
    cout << "Hello, World!"<< endl;
    return 0;
}`,
      explanation: "C++ is an extension of C with object-oriented features. The iostream library provides input/output functionality."
    },
    {
      title: "Classes and Objects",
      description: "Understanding object-oriented programming",
      icon: "üèóÔ∏è",
      difficulty: "Intermediate",
      definition: "Classes are user-defined data types that encapsulate data and functions. Objects are instances of classes that contain data and behavior.",
      keyConcepts: ["Encapsulation", "Data Hiding", "Member Functions", "Constructor/Destructor"],
      code: `class Student {
private:
    string name;
    int age;
    
public:
    Student(string n, int a) {
        name = n;
        age = a;
    }
    
    void display() {
        cout << "Name: "<< name << ", Age: "<< age << endl;
    }
};

int main() {
    Student student("John", 20);
    student.display();
    return 0;
}`,
      explanation: "Classes are user-defined data types that encapsulate data and functions. Objects are instances of classes."
    },
    {
      title: "Inheritance",
      description: "Creating class hierarchies",
      icon: "üå≥",
      difficulty: "Intermediate",
      definition: "Inheritance is a mechanism that allows a class to inherit properties and methods from another class, promoting code reuse and hierarchy.",
      keyConcepts: ["Code Reuse", "Hierarchy", "Base/Derived Classes", "Access Specifiers"],
      code: `class Person {
protected:
    string name;
public:
    Person(string n) : name(n) {}
    virtual void display() {
        cout << "Name: "<< name << endl;
    }
};

class Student : public Person {
private:
    int rollNo;
public:
    Student(string n, int r) : Person(n), rollNo(r) {}
    void display() override {
        cout << "Student: "<< name << ", Roll: "<< rollNo << endl;
    }
};`,
      explanation: "Inheritance allows a class to inherit properties from another class, promoting code reuse and hierarchy."
    },
    {
      title: "Polymorphism",
      description: "Using virtual functions and overriding",
      icon: "üîÑ",
      difficulty: "Advanced",
      definition: "Polymorphism allows objects of different classes to be treated as objects of a common base class through virtual functions.",
      keyConcepts: ["Virtual Functions", "Method Overriding", "Runtime Binding", "Abstract Classes"],
      code: `class Shape {
public:
    virtual void draw() = 0;  // Pure virtual function
    virtual ~Shape() {}
};

class Circle : public Shape {
public:
    void draw() override {
        cout << "Drawing Circle"<< endl;
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        cout << "Drawing Rectangle"<< endl;
    }
};`,
      explanation: "Polymorphism allows different classes to be treated as instances of the same base class through virtual functions."
    },
    {
      title: "Templates",
      description: "Generic programming with templates",
      icon: "üîß",
      difficulty: "Advanced",
      definition: "Templates allow generic programming by creating functions and classes that work with any data type without code duplication.",
      keyConcepts: ["Generic Programming", "Type Independence", "Code Reusability", "Compile-time Polymorphism"],
      code: `template <typename T>
T add(T a, T b) {
    return a + b;
}

template <typename T>
class Stack {
private:
    vector<T> elements;
public:
    void push(T element) {
        elements.push_back(element);
    }
    T pop() {
        T element = elements.back();
        elements.pop_back();
        return element;
    }
};`,
      explanation: "Templates allow generic programming by creating functions and classes that work with any data type."
    },
    {
      title: "STL (Standard Template Library)",
      description: "Using built-in data structures and algorithms",
      icon: "üìö",
      difficulty: "Intermediate",
      definition: "STL is a collection of template classes and functions that provide ready-to-use data structures and algorithms for efficient programming.",
      keyConcepts: ["Containers", "Algorithms", "Iterators", "Function Objects"],
      code: `#include <vector>
#include <algorithm>
#include <map>

int main() {
    // Vector
vector<int> numbers = {3, 1, 4, 1, 5};
sort(numbers.begin(), numbers.end());
    
    // Map
    map<string, int> scores;
    scores["Alice"] = 95;
    scores["Bob"] = 87;
    
    // Iterating
    for (const auto& pair : scores) {
        cout << pair.first << ": "<< pair.second << endl;
    }
    return 0;
}`,
      explanation: "STL provides ready-to-use data structures and algorithms for efficient programming."
    }
  ];

  const dsaTopics = [
    {
      title: "Introduction to Data Structures",
      description: "Understanding fundamental data organization",
      icon: "üèóÔ∏è",
      difficulty: "Beginner",
      definition: "Data structures are specialized formats for organizing and storing data in a computer so that it can be accessed and modified efficiently.",
      keyConcepts: ["Data Organization", "Memory Efficiency", "Access Patterns", "Algorithm Complexity"],
      code: `// Basic structure for a node
struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

// Array implementation
int arr[5] = {1, 2, 3, 4, 5};
cout << "Array element: "<< arr[2] << endl;`,
      explanation: "Data structures are ways of organizing and storing data for efficient access and modification."
    },
    {
      title: "Arrays and Vectors",
      description: "Linear data structures",
      icon: "üìä",
      difficulty: "Beginner",
      definition: "Arrays are collections of elements stored in contiguous memory locations. Vectors are dynamic arrays that can grow and shrink automatically.",
      keyConcepts: ["Contiguous Memory", "Index-based Access", "Dynamic Sizing", "Random Access"],
      code: `#include <vector>

// Static array
int staticArray[5] = {1, 2, 3, 4, 5};

// Dynamic vector
vector<int> dynamicArray = {1, 2, 3, 4, 5};
dynamicArray.push_back(6);  // Add element
dynamicArray.pop_back();     // Remove last element

// 2D array
int matrix[3][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};`,
      explanation: "Arrays store elements in contiguous memory. Vectors are dynamic arrays that can grow and shrink."
    },
    {
      title: "Linked Lists",
      description: "Dynamic data structure with nodes",
      icon: "üîó",
      difficulty: "Intermediate",
      definition: "Linked lists are linear data structures where elements are stored in nodes, and each node contains a data field and a reference to the next node.",
      keyConcepts: ["Node Structure", "Dynamic Memory", "Sequential Access", "Insertion/Deletion"],
      code: `struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

class LinkedList {
private:
    Node* head;
public:
    LinkedList() : head(nullptr) {}
    
    void insertAtEnd(int data) {
        Node* newNode = new Node(data);
        if (!head) {
            head = newNode;
            return;
        }
        Node* current = head;
        while (current->next) {
            current = current->next;
        }
        current->next = newNode;
    }
};`,
      explanation: "Linked lists consist of nodes connected by pointers. They allow dynamic memory allocation and efficient insertion/deletion."
    },
    {
      title: "Stacks and Queues",
      description: "LIFO and FIFO data structures",
      icon: "üìö",
      difficulty: "Intermediate",
      definition: "Stacks follow LIFO (Last In First Out) principle, while queues follow FIFO (First In First Out) principle for data access.",
      keyConcepts: ["LIFO/FIFO", "Push/Pop Operations", "Peek/Top", "Bounded/Unbounded"],
      code: `#include <stack>
#include <queue>

// Stack (LIFO)
stack<int> s;
s.push(10);
s.push(20);
int topElement = s.top();  // 20
s.pop();  // removes 20

// Queue (FIFO)
queue<int> q;
q.push(10);
q.push(20);
int frontElement = q.front();  // 10
q.pop();  // removes 10

// Custom Stack implementation
class CustomStack {
private:
    vector<int> elements;
public:
    void push(int val) { elements.push_back(val); }
    int pop() {
        int val = elements.back();
        elements.pop_back();
        return val;
    }
};`,
      explanation: "Stacks follow LIFO (Last In First Out) while queues follow FIFO (First In First Out) principle."
    },
    {
      title: "Trees and Binary Trees",
      description: "Hierarchical data structures",
      icon: "üå≥",
      difficulty: "Advanced",
      definition: "Trees are hierarchical data structures with nodes connected by edges. Binary trees have at most two children per node.",
      keyConcepts: ["Hierarchy", "Parent-Child Relationship", "Traversal", "Balanced/Unbalanced"],
      code: `struct TreeNode {
    int data;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int val) : data(val), left(nullptr), right(nullptr) {}
};

class BinaryTree {
private:
    TreeNode* root;
public:
    BinaryTree() : root(nullptr) {}
    
    void insert(int data) {
        root = insertRec(root, data);
    }
    
    TreeNode* insertRec(TreeNode* node, int data) {
        if (!node) return new TreeNode(data);
        if (data < node->data)
            node->left = insertRec(node->left, data);
        else
            node->right = insertRec(node->right, data);
        return node;
    }
};`,
      explanation: "Trees are hierarchical data structures. Binary trees have at most two children per node."
    },
    {
      title: "Graphs and Algorithms",
      description: "Complex data structures and algorithms",
      icon: "üï∏Ô∏è",
      difficulty: "Advanced",
      definition: "Graphs are data structures consisting of vertices (nodes) connected by edges. They represent relationships between objects.",
      keyConcepts: ["Vertices and Edges", "Directed/Undirected", "Weighted/Unweighted", "Traversal Algorithms"],
      code: `#include <vector>
#include <queue>

class Graph {
private:
    vector<vector<int>> adjacencyList;
    int vertices;
public:
    Graph(int v) : vertices(v) {
        adjacencyList.resize(v);
    }
    
    void addEdge(int u, int v) {
        adjacencyList[u].push_back(v);
        adjacencyList[v].push_back(u);  // Undirected
    }
    
    void BFS(int start) {
        vector<bool> visited(vertices, false);
queue<int> q;
        visited[start] = true;
        q.push(start);
        
        while (!q.empty()) {
            int vertex = q.front();
            cout << vertex << " ";
            q.pop();
            
            for (int neighbor : adjacencyList[vertex]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    q.push(neighbor);
                }
            }
        }
    }
};`,
      explanation: "Graphs represent relationships between objects. BFS and DFS are fundamental traversal algorithms."
    }
  ];

  const pythonTopics = [
    {
      title: "Introduction to Python",
      description: "Learn the basics of Python programming",
      icon: "üêç",
      difficulty: "Beginner",
      definition: "Python is a high-level, interpreted programming language known for its clear syntax and readability. It is widely used for web development, data analysis, artificial intelligence, and more.",
      keyConcepts: ["High-level Language", "Interpreted", "Readability", "Versatility"],
      code: `# Basic print statement
print("Hello, World!")

# Variables and data types
x = 10
y = 3.14
name = "Alice"
is_student = True

# Arithmetic operations
sum = x + y
product = x * y

# String operations
greeting = "Hello, " + name

# Conditional statements
if is_student:
    print("You are a student!")
else:
    print("You are not a student.")

# Loops
for i in range(5):
    print(i)

# Functions
def greet(name):
    print(f"Hello, {name}!")

greet("Bob")`,
      explanation: "Python is a high-level, interpreted programming language known for its clear syntax and readability."
    },
    {
      title: "Object-Oriented Programming in Python",
      description: "Understanding object-oriented programming concepts in Python",
      icon: "üèóÔ∏è",
      difficulty: "Intermediate",
      definition: "Python supports object-oriented programming. Classes are defined using the 'class' keyword, and objects are instances of classes.",
      keyConcepts: ["Classes", "Objects", "Methods", "Attributes"],
      code: `class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def display(self):
        print(f"Name: {self.name}, Age: {self.age}")

# Creating an object
person1 = Person("Alice", 25)
person1.display()`,
      explanation: "Python supports object-oriented programming. Classes are defined using the 'class' keyword, and objects are instances of classes."
    },
    {
      title: "Data Structures in Python",
      description: "Using built-in data structures in Python",
      icon: "üì¶",
      difficulty: "Intermediate",
      definition: "Python provides several built-in data structures: lists, dictionaries, sets, and tuples. These are mutable and can be modified after creation.",
      keyConcepts: ["Lists", "Dictionaries", "Sets", "Tuples"],
      code: `# List
my_list = [1, 2, 3, 4, 5]
my_list.append(6)
my_list.remove(3)

# Dictionary
my_dict = {"name": "Alice", "age": 25}
my_dict["city"] = "New York"

# Set
my_set = {1, 2, 3, 4, 5}
my_set.add(6)
my_set.remove(3)

# Tuple
my_tuple = (1, 2, 3)

# Accessing elements
print(my_list[0])
print(my_dict["name"])
print(my_set.pop())`,
      explanation: "Python provides several built-in data structures: lists, dictionaries, sets, and tuples. These are mutable and can be modified after creation."
    },
    {
      title: "Machine Learning Concepts",
      description: "Understanding fundamental machine learning concepts",
      icon: "üß†",
      difficulty: "Advanced",
      definition: "Machine learning is a subset of artificial intelligence that involves training algorithms to make predictions or decisions based on data.",
      keyConcepts: ["Supervised Learning", "Unsupervised Learning", "Regression", "Classification"],
      code: `# Supervised Learning Example (Linear Regression)
import numpy as np
import matplotlib.pyplot as plt

# Generate some data
X = np.array([1, 2, 3, 4, 5]).reshape(-1, 1)
y = np.array([2, 4, 6, 8, 10])

# Train a simple linear regression model
from sklearn.linear_model import LinearRegression
model = LinearRegression()
model.fit(X, y)

# Make predictions
predictions = model.predict(X)

# Plot the data and predictions
plt.scatter(X, y, color='blue', label='Actual Data')
plt.plot(X, predictions, color='red', label='Predicted Data')
plt.xlabel('X')
plt.ylabel('y')
plt.legend()
plt.show()`,
      explanation: "Machine learning is a subset of artificial intelligence that involves training algorithms to make predictions or decisions based on data."
    }
  ];

  const mlTopics = [
    {
      title: "Introduction to Machine Learning",
      description: "Understanding the basics of machine learning",
      icon: "üß†",
      difficulty: "Beginner",
      definition: "Machine learning is a subset of artificial intelligence that involves training algorithms to make predictions or decisions based on data.",
      keyConcepts: ["Supervised Learning", "Unsupervised Learning", "Regression", "Classification"],
      code: `# Supervised Learning Example (Linear Regression)
import numpy as np
import matplotlib.pyplot as plt

# Generate some data
X = np.array([1, 2, 3, 4, 5]).reshape(-1, 1)
y = np.array([2, 4, 6, 8, 10])

# Train a simple linear regression model
from sklearn.linear_model import LinearRegression
model = LinearRegression()
model.fit(X, y)

# Make predictions
predictions = model.predict(X)

# Plot the data and predictions
plt.scatter(X, y, color='blue', label='Actual Data')
plt.plot(X, predictions, color='red', label='Predicted Data')
plt.xlabel('X')
plt.ylabel('y')
plt.legend()
plt.show()`,
      explanation: "Machine learning is a subset of artificial intelligence that involves training algorithms to make predictions or decisions based on data."
    },
    {
      title: "Supervised Learning",
      description: "Training algorithms to make predictions",
      icon: "üß†",
      difficulty: "Intermediate",
      definition: "Supervised learning involves training an algorithm on labeled data to make predictions or decisions.",
      keyConcepts: ["Training Data", "Labels", "Predictions", "Model Evaluation"],
      code: `# Linear Regression Example
import numpy as np
import matplotlib.pyplot as plt

# Generate some data
X = np.array([1, 2, 3, 4, 5]).reshape(-1, 1)
y = np.array([2, 4, 6, 8, 10])

# Train a simple linear regression model
from sklearn.linear_model import LinearRegression
model = LinearRegression()
model.fit(X, y)

# Make predictions
predictions = model.predict(X)

# Plot the data and predictions
plt.scatter(X, y, color='blue', label='Actual Data')
plt.plot(X, predictions, color='red', label='Predicted Data')
plt.xlabel('X')
plt.ylabel('y')
plt.legend()
plt.show()`,
      explanation: "Supervised learning involves training an algorithm on labeled data to make predictions or decisions."
    },
    {
      title: "Unsupervised Learning",
      description: "Training algorithms on unlabeled data",
      icon: "üß†",
      difficulty: "Intermediate",
      definition: "Unsupervised learning involves training an algorithm on unlabeled data to discover patterns or structure.",
      keyConcepts: ["Unlabeled Data", "Patterns", "Clustering", "Dimensionality Reduction"],
      code: `# K-Means Clustering Example
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans

# Generate some data
X = np.array([[1, 2], [1, 4], [1, 0], [4, 2], [4, 4], [4, 0]])

# Train a K-Means model
kmeans = KMeans(n_clusters=2, random_state=0)
kmeans.fit(X)

# Get cluster centers and labels
centers = kmeans.cluster_centers_
labels = kmeans.labels_

# Plot the data and cluster centers
plt.scatter(X[:, 0], X[:, 1], c=labels, cmap='viridis')
plt.scatter(centers[:, 0], centers[:, 1], c='red', s=200, alpha=0.75)
plt.xlabel('Feature 1')
plt.ylabel('Feature 2')
plt.title('K-Means Clustering')
plt.show()`,
      explanation: "Unsupervised learning involves training an algorithm on unlabeled data to discover patterns or structure."
    },
    {
      title: "Deep Learning",
      description: "Using neural networks for complex tasks",
      icon: "üß†",
      difficulty: "Advanced",
      definition: "Deep learning is a subfield of machine learning that uses neural networks with multiple layers to learn representations of data.",
      keyConcepts: ["Neural Networks", "Layers", "Activation Functions", "Backpropagation"],
      code: `# Simple Neural Network Example
import numpy as np
import matplotlib.pyplot as plt
from sklearn.datasets import make_classification
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# Generate some data
X, y = make_classification(n_samples=100, n_features=2, n_informative=2, n_redundant=0, random_state=42)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Standardize features
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Train a simple neural network
from keras.models import Sequential
from keras.layers import Dense

model = Sequential()
model.add(Dense(4, input_dim=2, activation='relu'))
model.add(Dense(1, activation='sigmoid'))

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
model.fit(X_train_scaled, y_train, epochs=100, batch_size=5, verbose=0)

# Make predictions
predictions = model.predict(X_test_scaled)
predictions = (predictions > 0.5).astype(int)

# Plot the data and decision boundary
plt.scatter(X_test_scaled[:, 0], X_test_scaled[:, 1], c=y_test, cmap='viridis', alpha=0.6)
plt.xlabel('Feature 1')
plt.ylabel('Feature 2')
plt.title('Simple Neural Network Decision Boundary')
plt.show()`,
      explanation: "Deep learning is a subfield of machine learning that uses neural networks with multiple layers to learn representations of data."
    }
  ];

  const javaTopics = [
    {
      title: "Introduction to Java Programming",
      description: "Learn the basics of Java programming language",
      icon: "‚òï",
      difficulty: "Beginner",
      definition: "Java is a high-level, class-based, object-oriented programming language that is designed to have as few implementation dependencies as possible.",
      keyConcepts: ["Object-Oriented Programming", "Class-based", "Platform Independence", "Robustness"],
      code: `public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}`,
      explanation: "This is the basic structure of a Java program. The 'public' keyword makes the class accessible from outside, 'static' means it can be called without an instance, and 'void' means it doesn't return a value."
    },
    {
      title: "Variables and Data Types",
      description: "Understanding different data types in Java",
      icon: "üìä",
      difficulty: "Beginner",
      definition: "Variables are named memory locations that store data values. Data types define the type and size of data that can be stored in variables.",
      keyConcepts: ["Memory Allocation", "Type Safety", "Size Specifications", "Value Storage"],
      code: `public class Variables {
    public static void main(String[] args) {
        int age = 25;
        float salary = 50000.50f;
        char grade = 'A';
        double pi = 3.14159;

        System.out.println("Age: " + age);
        System.out.println("Salary: " + salary);
        System.out.println("Grade: " + grade);
        System.out.println("Pi: " + pi);
    }
}`,
      explanation: "Java supports various data types: int for integers, float for decimals, char for characters, and double for high-precision decimals."
    },
    {
      title: "Control Structures",
      description: "Mastering loops and conditional statements",
      icon: "üîÑ",
      difficulty: "Intermediate",
      definition: "Control structures are programming constructs that determine the flow of program execution based on conditions and loops.",
      keyConcepts: ["Conditional Logic", "Loop Control", "Flow Control", "Decision Making"],
      code: `public class ControlStructures {
    public static void main(String[] args) {
        int age = 20;

        // If-else statement
        if (age >= 18) {
            System.out.println("Adult");
        } else {
            System.out.println("Minor");
        }

        // For loop
        for (int i = 0; i < 10; i++) {
            System.out.print(i + " ");
        }
        System.out.println();

        // While loop
        int count = 0;
        while (count < 5) {
            System.out.println("Count: " + count);
            count++;
        }
    }
}`,
      explanation: "Control structures allow you to make decisions and repeat code blocks. Use if-else for conditions, for/while for loops."
    },
    {
      title: "Functions",
      description: "Creating reusable code blocks",
      icon: "‚öôÔ∏è",
      difficulty: "Intermediate",
      definition: "Functions are self-contained blocks of code that perform specific tasks. They promote code reusability and modularity.",
      keyConcepts: ["Code Reusability", "Modularity", "Parameter Passing", "Return Values"],
      code: `public class Functions {
    public static int add(int a, int b) {
        return a + b;
    }

    public static void greet(String name) {
        System.out.println("Hello, " + name + "!");
    }

    public static void main(String[] args) {
        int result = add(5, 3);
        System.out.println("Sum: " + result);
        
        greet("Student");
    }
}`,
      explanation: "Functions help organize code into reusable blocks. They can return values or perform actions without returning anything (void)."
    },
    {
      title: "Arrays",
      description: "Working with collections of data",
      icon: "üì¶",
      difficulty: "Intermediate",
      definition: "Arrays are collections of elements of the same data type stored in contiguous memory locations.",
      keyConcepts: ["Contiguous Memory", "Index-based Access", "Fixed Size", "Homogeneous Data"],
      code: `public class Arrays {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};

        // Accessing array elements
        System.out.println("First element: " + numbers[0]);
        System.out.println("Last element: " + numbers[4]);

        // Looping through array
        for (int i = 0; i < 5; i++) {
            System.out.println("numbers[" + i + "] = " + numbers[i]);
        }
    }
}`,
      explanation: "Arrays store multiple values of the same type. Elements are accessed using index numbers starting from 0."
    },
    {
      title: "Pointers",
      description: "Understanding memory addresses",
      icon: "üìç",
      difficulty: "Advanced",
      definition: "Pointers are variables that store memory addresses of other variables. They provide direct access to memory locations.",
      keyConcepts: ["Memory Addresses", "Indirect Access", "Dynamic Memory", "Address Arithmetic"],
      code: `public class Pointers {
    public static void main(String[] args) {
        int number = 42;
        int *ptr = &number;  // Pointer to number

        System.out.println("Value: " + number);
        System.out.println("Address: " + ptr);
        System.out.println("Pointer value: " + *ptr);

        // Modifying value through pointer
        *ptr = 100;
        System.out.println("New value: " + number);
    }
}`,
      explanation: "Pointers store memory addresses. They allow direct manipulation of memory and are fundamental to C programming."
    }
  ];

  const dsaWithPythonTopics = [
    {
      title: "Introduction to DSA with Python",
      description: "Understanding data structures and algorithms using Python",
      icon: "üêç",
      difficulty: "Beginner",
      definition: "Data Structures and Algorithms (DSA) with Python combines the power of Python's built-in data structures with algorithmic thinking to solve complex problems efficiently.",
      keyConcepts: ["Python Data Structures", "Algorithm Design", "Time Complexity", "Space Complexity"],
      code: `# Introduction to DSA with Python
import time

def measure_time(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"Function {func.__name__} took {end - start:.6f} seconds")
        return result
    return wrapper

@measure_time
def linear_search(arr, target):
    for i, element in enumerate(arr):
        if element == target:
            return i
    return -1

# Example usage
numbers = [1, 3, 5, 7, 9, 11, 13, 15]
target = 7
result = linear_search(numbers, target)
print(f"Element {target} found at index: {result}")`,
      explanation: "Python provides excellent built-in data structures and libraries for implementing algorithms efficiently. The time module helps measure algorithm performance."
    },
    {
      title: "Arrays and Lists in Python",
      description: "Working with arrays and dynamic lists",
      icon: "üì¶",
      difficulty: "Beginner",
      definition: "Python lists are dynamic arrays that can store elements of different types. They provide efficient indexing and slicing operations.",
      keyConcepts: ["Dynamic Arrays", "Indexing", "Slicing", "List Comprehensions"],
      code: `# Arrays and Lists in Python
import array

# Using Python list (dynamic array)
numbers = [1, 2, 3, 4, 5]
print(f"Original list: {numbers}")

# Adding elements
numbers.append(6)
numbers.insert(0, 0)
print(f"After adding elements: {numbers}")

# Removing elements
numbers.remove(3)
popped = numbers.pop()
print(f"After removing elements: {numbers}")
print(f"Popped element: {popped}")

# List comprehension
squares = [x**2 for x in range(1, 6)]
print(f"Squares: {squares}")

# Using array module for type-specific arrays
int_array = array.array('i', [1, 2, 3, 4, 5])
print(f"Integer array: {int_array}")`,
      explanation: "Python lists are versatile and can store any type of data. They provide efficient operations for adding, removing, and accessing elements."
    },
    {
      title: "Stacks and Queues",
      description: "Implementing stack and queue data structures",
      icon: "üìö",
      difficulty: "Intermediate",
      definition: "Stacks follow LIFO (Last In, First Out) principle, while queues follow FIFO (First In, First Out) principle. Both are fundamental data structures.",
      keyConcepts: ["LIFO", "FIFO", "Push/Pop", "Enqueue/Dequeue"],
      code: `# Stacks and Queues in Python
from collections import deque

# Stack implementation using list
class Stack:
    def __init__(self):
        self.items = []
    
    def push(self, item):
        self.items.append(item)
    
    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        return None
    
    def peek(self):
        if not self.is_empty():
            return self.items[-1]
        return None
    
    def is_empty(self):
        return len(self.items) == 0
    
    def size(self):
        return len(self.items)

# Queue implementation using deque
class Queue:
    def __init__(self):
        self.items = deque()
    
    def enqueue(self, item):
        self.items.append(item)
    
    def dequeue(self):
        if not self.is_empty():
            return self.items.popleft()
        return None
    
    def front(self):
        if not self.is_empty():
            return self.items[0]
        return None
    
    def is_empty(self):
        return len(self.items) == 0
    
    def size(self):
        return len(self.items)

# Example usage
stack = Stack()
stack.push(1)
stack.push(2)
stack.push(3)
print(f"Stack: {stack.items}")
print(f"Popped: {stack.pop()}")

queue = Queue()
queue.enqueue('A')
queue.enqueue('B')
queue.enqueue('C')
print(f"Queue: {list(queue.items)}")
print(f"Dequeued: {queue.dequeue()}")`,
      explanation: "Stacks and queues are fundamental data structures. Stacks use LIFO principle, while queues use FIFO principle."
    },
    {
      title: "Linked Lists",
      description: "Implementing linked list data structure",
      icon: "üîó",
      difficulty: "Intermediate",
      definition: "A linked list is a linear data structure where elements are stored in nodes, and each node points to the next node in the sequence.",
      keyConcepts: ["Nodes", "Pointers", "Head/Tail", "Traversal"],
      code: `# Linked List implementation in Python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
    
    def insert_at_beginning(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
    
    def insert_at_end(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
            return
        
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node
    
    def delete_node(self, key):
        current = self.head
        
        # If head node itself holds the key
        if current and current.data == key:
            self.head = current.next
            current = None
            return
        
        # Search for the key to delete
        while current and current.next:
            if current.next.data == key:
                current.next = current.next.next
                return
            current = current.next
    
    def display(self):
        current = self.head
        elements = []
        while current:
            elements.append(str(current.data))
            current = current.next
        return " ->".join(elements)
    
    def search(self, key):
        current = self.head
        position = 0
        while current:
            if current.data == key:
                return position
            current = current.next
            position += 1
        return -1

# Example usage
ll = LinkedList()
ll.insert_at_end(1)
ll.insert_at_end(2)
ll.insert_at_end(3)
ll.insert_at_beginning(0)
print(f"Linked List: {ll.display()}")
print(f"Search 2 at position: {ll.search(2)}")
ll.delete_node(2)
print(f"After deleting 2: {ll.display()}")`,
      explanation: "Linked lists consist of nodes where each node contains data and a reference to the next node. They provide efficient insertion and deletion."
    },
    {
      title: "Trees and Binary Trees",
      description: "Understanding tree data structures",
      icon: "üå≥",
      difficulty: "Intermediate",
      definition: "A tree is a hierarchical data structure with a root node and child nodes. A binary tree is a tree where each node has at most two children.",
      keyConcepts: ["Root", "Parent/Child", "Leaf", "Traversal"],
      code: `# Binary Tree implementation in Python
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

class BinaryTree:
    def __init__(self):
        self.root = None
    
    def insert(self, data):
        if self.root is None:
            self.root = TreeNode(data)
        else:
            self._insert_recursive(self.root, data)
    
    def _insert_recursive(self, node, data):
        if data < node.data:
            if node.left is None:
                node.left = TreeNode(data)
            else:
                self._insert_recursive(node.left, data)
        else:
            if node.right is None:
                node.right = TreeNode(data)
            else:
                self._insert_recursive(node.right, data)
    
    def inorder_traversal(self, node=None):
        if node is None:
            node = self.root
        if node:
            self.inorder_traversal(node.left)
            print(node.data, end=" ")
            self.inorder_traversal(node.right)
    
    def preorder_traversal(self, node=None):
        if node is None:
            node = self.root
        if node:
            print(node.data, end=" ")
            self.preorder_traversal(node.left)
            self.preorder_traversal(node.right)
    
    def postorder_traversal(self, node=None):
        if node is None:
            node = self.root
        if node:
            self.postorder_traversal(node.left)
            self.postorder_traversal(node.right)
            print(node.data, end=" ")
    
    def search(self, key):
        return self._search_recursive(self.root, key)
    
    def _search_recursive(self, node, key):
        if node is None or node.data == key:
            return node
        if key < node.data:
            return self._search_recursive(node.left, key)
        return self._search_recursive(node.right, key)

# Example usage
bt = BinaryTree()
bt.insert(5)
bt.insert(3)
bt.insert(7)
bt.insert(1)
bt.insert(9)

print("Inorder traversal:", end=" ")
bt.inorder_traversal()
print()

print("Preorder traversal:", end=" ")
bt.preorder_traversal()
print()

print("Postorder traversal:", end=" ")
bt.postorder_traversal()
print()

# Search for a node
result = bt.search(3)
if result:
    print(f"Found node with data: {result.data}")
else:
    print("Node not found")`,
      explanation: "Trees are hierarchical data structures. Binary trees have at most two children per node. Traversal methods include inorder, preorder, and postorder."
    },
    {
      title: "Graphs and Graph Algorithms",
      description: "Working with graph data structures",
      icon: "üï∏Ô∏è",
      difficulty: "Advanced",
      definition: "A graph is a collection of nodes (vertices) connected by edges. Graphs can be directed or undirected and are used to model relationships.",
      keyConcepts: ["Vertices", "Edges", "Adjacency", "Traversal"],
      code: `# Graph implementation in Python
from collections import defaultdict, deque

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)
    
    def add_edge(self, u, v):
        self.graph[u].append(v)
    
    def bfs(self, start):
        visited = set()
        queue = deque([start])
        visited.add(start)
        result = []
        
        while queue:
            vertex = queue.popleft()
            result.append(vertex)
            
            for neighbor in self.graph[vertex]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        return result
    
    def dfs(self, start, visited=None):
        if visited is None:
            visited = set()
        
        visited.add(start)
        result = [start]
        
        for neighbor in self.graph[start]:
            if neighbor not in visited:
                result.extend(self.dfs(neighbor, visited))
        
        return result
    
    def has_cycle(self):
        visited = set()
        rec_stack = set()
        
        def dfs_cycle(node):
            visited.add(node)
            rec_stack.add(node)
            
            for neighbor in self.graph[node]:
                if neighbor not in visited:
                    if dfs_cycle(neighbor):
                        return True
                elif neighbor in rec_stack:
                    return True
            
            rec_stack.remove(node)
            return False
        
        for node in self.graph:
            if node not in visited:
                if dfs_cycle(node):
                    return True
        return False

# Example usage
g = Graph()
g.add_edge(0, 1)
g.add_edge(0, 2)
g.add_edge(1, 2)
g.add_edge(2, 0)
g.add_edge(2, 3)
g.add_edge(3, 3)

print("BFS starting from vertex 2:")
print(g.bfs(2))

print("DFS starting from vertex 2:")
print(g.dfs(2))

print(f"Graph has cycle: {g.has_cycle()}")`,
      explanation: "Graphs represent relationships between objects. BFS explores level by level, while DFS explores as far as possible along each branch."
    },
    {
      title: "Sorting Algorithms",
      description: "Implementing various sorting algorithms",
      icon: "üìä",
      difficulty: "Intermediate",
      definition: "Sorting algorithms arrange elements in a specific order. Different algorithms have different time and space complexities.",
      keyConcepts: ["Time Complexity", "Space Complexity", "Stability", "In-place"],
      code: `# Sorting Algorithms in Python
import time

def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result

def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)

# Example usage
arr = [64, 34, 25, 12, 22, 11, 90]
print(f"Original array: {arr}")

# Test different sorting algorithms
algorithms = [
    ("Bubble Sort", bubble_sort),
    ("Selection Sort", selection_sort),
    ("Insertion Sort", insertion_sort),
    ("Merge Sort", merge_sort),
    ("Quick Sort", quick_sort)
]

for name, algorithm in algorithms:
    test_arr = arr.copy()
    start_time = time.time()
    sorted_arr = algorithm(test_arr)
    end_time = time.time()
    print(f"{name}: {sorted_arr} (Time: {end_time - start_time:.6f}s)")`,
      explanation: "Different sorting algorithms have different trade-offs. Bubble sort is simple but slow, while quick sort is fast but complex."
    },
    {
      title: "Searching Algorithms",
      description: "Implementing various searching algorithms",
      icon: "üîç",
      difficulty: "Intermediate",
      definition: "Searching algorithms find specific elements in data structures. Different algorithms work best for different scenarios.",
      keyConcepts: ["Linear Search", "Binary Search", "Time Complexity", "Space Complexity"],
      code: `# Searching Algorithms in Python
import time

def linear_search(arr, target):
    for i, element in enumerate(arr):
        if element == target:
            return i
    return -1

def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1

def binary_search_recursive(arr, target, left=0, right=None):
    if right is None:
        right = len(arr) - 1
    
    if left > right:
        return -1
    
    mid = (left + right) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)

def jump_search(arr, target):
    n = len(arr)
    step = int(n ** 0.5)
    
    # Finding the block where element is present
    prev = 0
    while prev < n and arr[min(step, n) - 1] < target:
        prev = step
        step += int(n ** 0.5)
        if prev >= n:
            return -1
    
    # Linear search in the identified block
    while prev < min(step, n):
        if arr[prev] == target:
            return prev
        prev += 1
    
    return -1

# Example usage
arr = [2, 3, 4, 10, 40, 50, 60, 70, 80, 90, 100]
target = 10
print(f"Array: {arr}")
print(f"Searching for: {target}")

# Test different searching algorithms
algorithms = [
    ("Linear Search", linear_search),
    ("Binary Search", binary_search),
    ("Binary Search (Recursive)", binary_search_recursive),
    ("Jump Search", jump_search)
]

for name, algorithm in algorithms:
    start_time = time.time()
    result = algorithm(arr, target)
    end_time = time.time()
    if result != -1:
        print(f"{name}: Found at index {result} (Time: {end_time - start_time:.6f}s)")
    else:
        print(f"{name}: Not found (Time: {end_time - start_time:.6f}s)")`,
      explanation: "Linear search works on any array but is slow. Binary search is fast but requires sorted arrays. Jump search is a compromise between the two."
    },
    {
      title: "Dynamic Programming",
      description: "Solving problems using dynamic programming",
      icon: "üß©",
      difficulty: "Advanced",
      definition: "Dynamic programming is a method for solving complex problems by breaking them down into simpler subproblems and storing the results.",
      keyConcepts: ["Memoization", "Tabulation", "Optimal Substructure", "Overlapping Subproblems"],
      code: `# Dynamic Programming Examples in Python

# Fibonacci with memoization
def fibonacci_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    
    memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo)
    return memo[n]

# Fibonacci with tabulation
def fibonacci_tab(n):
    if n <= 1:
        return n
    
    dp = [0] * (n + 1)
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    
    return dp[n]

# Longest Common Subsequence
def lcs(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    
    return dp[m][n]

# Knapsack Problem
def knapsack(weights, values, capacity):
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            if weights[i - 1] <= w:
                dp[i][w] = max(dp[i - 1][w], 
                              dp[i - 1][w - weights[i - 1]] + values[i - 1])
            else:
                dp[i][w] = dp[i - 1][w]
    
    return dp[n][capacity]

# Example usage
print("Fibonacci with memoization:")
for i in range(10):
    print(f"F({i}) = {fibonacci_memo(i)}")

print("\\nFibonacci with tabulation:")
for i in range(10):
    print(f"F({i}) = {fibonacci_tab(i)}")

print("\\nLongest Common Subsequence:")
str1 = "ABCDGH"
str2 = "AEDFHR"
print(f"LCS of '{str1}' and '{str2}': {lcs(str1, str2)}")

print("\\nKnapsack Problem:")
weights = [2, 1, 3, 2]
values = [12, 10, 20, 15]
capacity = 5
print(f"Maximum value: {knapsack(weights, values, capacity)}")`,
      explanation: "Dynamic programming solves complex problems by breaking them into simpler subproblems and storing results to avoid redundant calculations."
    }
  ];

  const copyToClipboard = async (text: string, index: number) => {
    try {
      await navigator.clipboard.writeText(text);
      setCopiedIndex(index);
      setTimeout(() => setCopiedIndex(null), 2000);
    } catch (err) {
      console.error('Failed to copy text: ', err);
    }
  };

  const renderTopics = (topics: { title: string; description: string; code?: string; }[], language: string) => (
    <Box sx={{ display: 'grid', gridTemplateColumns: { xs: '1fr', md: '1fr 1fr' }, gap: 4 }}>
      {topics.map((topic, index) => (
        <motion.div
          key={index}
          initial={{ opacity: 0, y: 30 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8, delay: index * 0.1 }}
        >
          <Paper
            elevation={0}
      sx={{
              background: 'rgba(255, 255, 255, 0.05)',
              backdropFilter: 'blur(20px)',
              border: '1px solid rgba(255, 255, 255, 0.1)',
              borderRadius: 3,
              p: 3,
              height: '100%',
              transition: 'all 0.3s ease',
              '&:hover': {
                transform: 'translateY(-8px)',
                boxShadow: '0 20px 40px rgba(0, 0, 0, 0.3)',
                border: '1px solid rgba(0, 212, 255, 0.3)',
              },
            }}
          >
              {/* Topic Header */}
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                <Typography
                  variant="h3"
                  sx={{ mr: 2, fontSize: '2rem' }}
                >
                  {topic.icon}
                </Typography>
                <Box>
                  <Typography
                    variant="h6"
        sx={{ 
                      color: '#fff',
                      fontWeight: 600,
                      mb: 0.5,
                    }}
                  >
                    {topic.title}
                  </Typography>
                  <Chip
                    label={topic.difficulty}
                    size="small"
            sx={{
                      background: topic.difficulty === 'Beginner' 
                        ? 'linear-gradient(135deg, #4caf50 0%, #45a049 100%)'
                        : topic.difficulty === 'Intermediate'
                        ? 'linear-gradient(135deg, #ff9800 0%, #f57c00 100%)'
                        : 'linear-gradient(135deg, #f44336 0%, #d32f2f 100%)',
                      color: '#fff',
              fontWeight: 600,
                    }}
                  />
                </Box>
              </Box>
          
          <Typography
                variant="body2"
            sx={{
                  color: '#b0b0b0',
                  mb: 3,
                  lineHeight: 1.6,
                }}
              >
                {topic.description}
          </Typography>

              {/* Definition Section */}
              <Box sx={{ mb: 3 }}>
                <Typography
                  variant="subtitle2"
              sx={{
                    color: '#00d4ff',
                    fontWeight: 600,
                    mb: 1,
                    fontSize: '0.9rem',
                  }}
                >
                  üìñ Definition
                </Typography>
              <Typography
                  variant="body2"
                sx={{
                    color: '#d4d4d4',
                    lineHeight: 1.6,
                    mb: 2,
                    fontStyle: 'italic',
                  }}
                >
                  {topic.definition}
              </Typography>
              
                {/* Key Concepts */}
              <Typography
                  variant="subtitle2"
                sx={{
                    color: '#00d4ff',
                    fontWeight: 600,
                    mb: 1,
                    fontSize: '0.9rem',
                  }}
                >
                  üéØ Key Concepts
              </Typography>
                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mb: 2 }}>
                  {topic.keyConcepts.map((concept: string, idx: number) => (
                    <Chip
                      key={idx}
                      label={concept}
                      size="small"
                      sx={{
                        background: 'rgba(0, 212, 255, 0.1)',
                        color: '#00d4ff',
                        border: '1px solid rgba(0, 212, 255, 0.3)',
                        fontSize: '0.75rem',
                        height: '24px',
                      }}
                    />
                  ))}
                </Box>
                </Box>

              {/* Code Editor */}
              <Box
                sx={{
                  background: '#1e1e1e',
                  borderRadius: 2,
                  p: 2,
                  mb: 2,
                  border: '1px solid rgba(255, 255, 255, 0.1)',
                  position: 'relative',
                }}
              >
                {/* Code Editor Header */}
                <Box
                  sx={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    mb: 2,
                    pb: 1,
                    borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
                  }}
                >
                  <Typography
                    variant="caption"
                    sx={{ color: '#888', fontWeight: 600 }}
                  >
                    {language === 'C' ? 'main.c' : language === 'C++' ? 'main.cpp' : 'main.cpp'}
                  </Typography>
                                      <Box sx={{ display: 'flex', gap: 1 }}>
                      <IconButton
                        size="small"
                        onClick={() => copyToClipboard(topic.code, index)}
                        sx={{
                          color: copiedIndex === index ? '#4caf50' : '#888',
                          '&:hover': { color: '#00d4ff' },
                        }}
                      >
                        {copiedIndex === index ? <CheckCircleIcon /> : <ContentCopyIcon />}
                      </IconButton>
                      <IconButton
                        size="small"
                        onClick={() => runningCode === index ? stopCode(index) : runCode(index, topic.code, language)}
                        sx={{
                          color: runningCode === index ? '#f44336' : '#888',
                          '&:hover': { color: runningCode === index ? '#ff4444' : '#00d4ff' },
                        }}
                      >
                        {runningCode === index ? <StopIcon /> : <PlayArrowIcon />}
                      </IconButton>
                </Box>
              </Box>

                {/* Code Content */}
                <Box
                  component="pre"
                  sx={{
                    color: '#d4d4d4',
                    fontFamily: '"Fira Code", "Monaco", "Consolas", monospace',
                    fontSize: '0.875rem',
                    lineHeight: 1.5,
                    margin: 0,
                    whiteSpace: 'pre-wrap',
                    wordBreak: 'break-word',
                    '& .keyword': { color: '#569cd6' },
                    '& .string': { color: '#ce9178' },
                    '& .comment': { color: '#6a9955' },
                    '& .function': { color: '#dcdcaa' },
                    '& .number': { color: '#b5cea8' },
                    '& .class': { color: '#4ec9b0' },
                  }}
                  dangerouslySetInnerHTML={{
                    __html: topic.code
                      .replace(/\b(int|void|return|if|else|for|while|printf|include|main|class|public|private|protected|virtual|template|typename|vector|map|stack|queue|struct|new|delete|cout|cin|endl|using|namespace|std|def|import|from|as|True|False|None|self|__init__|print|range|len|append|remove|add|pop|fit|predict|transform|reshape|array|plt|show|scatter|plot|legend|xlabel|ylabel|title|cmap|alpha|random_state|test_size|n_clusters|n_samples|n_features|n_informative|n_redundant|epochs|batch_size|verbose|optimizer|loss|metrics|accuracy|binary_crossentropy|adam|relu|sigmoid|Sequential|Dense|KMeans|LinearRegression|make_classification|StandardScaler|train_test_split|static|String|System|out|println|args|HelloWorld|Variables|ControlStructures|Functions|Arrays|Pointers)\b/g, '<span class="keyword">$1</span>')
                      .replace(/"([^"]*)"/g, '<span class="string">"$1"</span>')
                      .replace(/'([^']*)'/g, '<span class="string">\'$1\'</span>')
                      .replace(/\b(\d+\.?\d*)\b/g, '<span class="number">$1</span>')
                      .replace(/\b(printf|cout|cin|endl|print|fit|predict|transform|reshape|append|remove|add|pop|show|scatter|plot|legend|xlabel|ylabel|title|System\.out\.println)\b/g, '<span class="function">$1</span>')
                      .replace(/\b(Student|Person|Shape|Circle|Rectangle|Node|TreeNode|Graph|LinkedList|BinaryTree|CustomStack|Person|LinearRegression|KMeans|Sequential|Dense|StandardScaler|HelloWorld|Variables|ControlStructures|Functions|Arrays|Pointers)\b/g, '<span class="class">$1</span>')
                      .replace(/#.*$/gm, '<span class="comment">$&</span>')
                  }}
                />

                {/* Input Prompt */}
                {showInputPrompt === index && (
                  <Box
                    sx={{
                      mt: 2,
                      p: 2,
                      background: '#2a2a2a',
                      borderRadius: 1,
                      border: '1px solid rgba(255, 255, 255, 0.1)',
                      position: 'relative',
                    }}
                  >
              <Typography
                      variant="caption"
                sx={{
                        color: '#ff9800',
                        fontWeight: 600,
                        display: 'block',
                        mb: 1,
                      }}
                    >
                      üì• Input Required
              </Typography>
                    <Typography
                      variant="body2"
                    sx={{
                        color: '#d4d4d4',
                        mb: 2,
                        fontFamily: '"Fira Code", "Monaco", "Consolas", monospace',
                      }}
                    >
                      {userInputs[index]?.[currentInputIndex]}
                    </Typography>
                    <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
                      <input
                        type="text"
                        value={inputValues[currentInputIndex] || ''}
                        onChange={(e) => handleInputChange(e.target.value)}
                        onKeyPress={(e) => {
                          if (e.key === 'Enter') {
                            handleInputSubmit(index, topic.code, language);
                          }
                        }}
                        style={{
                          background: '#1e1e1e',
                          border: '1px solid rgba(255, 255, 255, 0.2)',
                          borderRadius: '4px',
                          padding: '8px 12px',
                          color: '#d4d4d4',
                          fontFamily: '"Fira Code", "Monaco", "Consolas", monospace',
                          fontSize: '0.875rem',
                          outline: 'none',
                          flex: 1,
                        }}
                        placeholder="Enter value..."
                      />
                      <Button
                        size="small"
                        variant="contained"
                        onClick={() => handleInputSubmit(index, topic.code, language)}
                    sx={{
                          background: 'linear-gradient(135deg, #00d4ff 0%, #0099cc 100%)',
                          color: '#fff',
                          px: 2,
                          py: 0.5,
                          fontSize: '0.75rem',
                      '&:hover': {
                            background: 'linear-gradient(135deg, #0099cc 0%, #007399 100%)',
                      },
                    }}
                  >
                        Submit
                      </Button>
                    </Box>
                  </Box>
                )}

                {/* Output Display */}
                {codeOutputs[index] && (
                  <Box
                    sx={{
                      mt: 2,
                      p: 2,
                      background: '#2a2a2a',
                      borderRadius: 1,
                      border: '1px solid rgba(255, 255, 255, 0.1)',
                      position: 'relative',
                    }}
                  >
                    <Typography
                      variant="caption"
                      sx={{
                        color: '#4caf50',
                        fontWeight: 600,
                        display: 'block',
                        mb: 1,
                      }}
                    >
                      üì§ Output
                    </Typography>
                    <Box
                      component="pre"
                      sx={{
                        color: '#d4d4d4',
                        fontFamily: '"Fira Code", "Monaco", "Consolas", monospace',
                        fontSize: '0.875rem',
                        lineHeight: 1.5,
                        margin: 0,
                        whiteSpace: 'pre-wrap',
                        wordBreak: 'break-word',
                      }}
                    >
                      {codeOutputs[index]}
            </Box>
                  </Box>
                )}
              </Box>

              {/* Explanation */}
                <Typography
                variant="body2"
                  sx={{
                  color: '#888',
                  fontStyle: 'italic',
                  lineHeight: 1.6,
                  }}
                >
                {topic.explanation}
                </Typography>
            </Paper>
          </motion.div>
        ))}
              </Box>
    );

  return (
    <>
      <AnimatePresence>
        {!isLoaded && (
          <motion.div
            initial={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.5 }}
          >
            <Loader animationData={programersWorking} overlay />
          </motion.div>
        )}
      </AnimatePresence>
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: isLoaded ? 1 : 0 }}
        transition={{ duration: 0.8, delay: 0.2 }}
      >
        <Box
          sx={{
            minHeight: '100vh',
            background: 'linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%)',
            position: 'relative',
            overflow: 'hidden',
          }}
        >
          {/* Animated Background Elements */}
          <Box
            component={motion.div}
            animate={{
              scale: [1, 1.1, 1],
              rotate: [0, 180, 360],
            }}
            transition={{
              duration: 20,
              repeat: Infinity,
              ease: "linear"
            }}
                            sx={{
              position: 'absolute',
              top: '10%',
              right: '10%',
              width: '300px',
              height: '300px',
              borderRadius: '50%',
              background: 'radial-gradient(circle, rgba(0, 123, 255, 0.1) 0%, transparent 70%)',
              filter: 'blur(40px)',
              zIndex: 0,
            }}
          />
          <Box
            component={motion.div}
            animate={{
              scale: [1.1, 1, 1.1],
              rotate: [360, 180, 0],
            }}
            transition={{
              duration: 25,
              repeat: Infinity,
              ease: "linear"
            }}
            sx={{
              position: 'absolute',
              bottom: '10%',
              left: '5%',
              width: '250px',
              height: '250px',
              borderRadius: '50%',
              background: 'radial-gradient(circle, rgba(255, 107, 53, 0.1) 0%, transparent 70%)',
              filter: 'blur(30px)',
              zIndex: 0,
            }}
          />

          {/* Navigation Bar */}
          <AppBar
            position="fixed"
            sx={{
              background: 'rgba(15, 15, 35, 0.95)',
              backdropFilter: 'blur(20px)',
              borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
              boxShadow: '0 8px 32px rgba(0, 0, 0, 0.3)',
            }}
          >
            <Toolbar>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
              <Button
                startIcon={<ArrowBackIcon />}
                onClick={() => router.back()}
                sx={{
                  color: '#fff',
                  '&:hover': { background: 'rgba(255, 255, 255, 0.1)' },
                }}
              >
                Back
              </Button>
              <Box sx={{ textAlign: 'left', flex: 1, minWidth: 0 }}>
                            <Typography
                              variant="h6"
                              sx={{
                    color: '#fff',
                    fontWeight: 700,
                    fontSize: { xs: '0.7rem', sm: '0.8rem', md: '0.9rem' },
                    lineHeight: 1.2,
                    wordBreak: 'break-all',
                    overflowWrap: 'break-word',
                    whiteSpace: 'pre-line',
                  }}
                >
                  SHETTY_SIR's{'\n'}CODING_ACADEMY
                            </Typography>
                          <Typography
                  variant="caption"
                            sx={{
                    color: '#00d4ff',
                    fontWeight: 600,
                    fontSize: '0.75rem',
                    letterSpacing: '0.5px',
                  }}
                >
                  Code, Create, Conquer!
                          </Typography>
              </Box>
            </Box>
            <Box sx={{ flexGrow: 1 }} />
            <Chip
              icon={<CodeIcon />}
              label="Programming Basics"
              sx={{
                background: 'linear-gradient(135deg, #00d4ff 0%, #0099cc 100%)',
                color: '#fff',
                fontWeight: 600,
              }}
            />
          </Toolbar>
        </AppBar>

        <Container maxWidth="lg" sx={{ pt: '80px', pb: 4 }}>
          {/* Hero Section */}
            <motion.div
            initial={{ opacity: 0, y: 30 }}
              animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.8 }}
            >
            <Box sx={{ textAlign: 'center', mb: 6 }}>
                  <Typography
                variant="h1"
                    sx={{
                  fontSize: { xs: '2.5rem', sm: '3.5rem', md: '4rem' },
                  fontWeight: 900,
                  background: 'linear-gradient(135deg, #00d4ff 0%, #0099cc 100%)',
                  backgroundClip: 'text',
                  WebkitBackgroundClip: 'text',
                  WebkitTextFillColor: 'transparent',
                  mb: 2,
                }}
              >
                Programming Basics
              </Typography>
              <Typography
                variant="h5"
                sx={{
                  color: '#b0b0b0',
                  fontWeight: 400,
                  maxWidth: '600px',
                  mx: 'auto',
                }}
              >
                Master C, C++, Java, Python, Data Structures & Algorithms, and Machine Learning with interactive examples
                  </Typography>
              </Box>
          </motion.div>

          {/* Tab Navigation */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.8, delay: 0.2 }}
          >
            <Paper
              elevation={0}
                        sx={{
                background: 'rgba(255, 255, 255, 0.05)',
                backdropFilter: 'blur(20px)',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                borderRadius: 3,
                mb: 4,
                overflow: 'hidden',
              }}
            >
              <Tabs
                value={activeTab}
                onChange={(e, newValue) => setActiveTab(newValue)}
                variant="scrollable"
                scrollButtons="auto"
                allowScrollButtonsMobile
                          sx={{
                  '& .MuiTab-root': {
                    color: '#b0b0b0',
                    fontWeight: 600,
                    textTransform: 'none',
                    fontSize: '1rem',
                    minHeight: '64px',
                    minWidth: 'auto',
                    padding: '12px 16px',
                    '&.Mui-selected': {
                      color: '#00d4ff',
                    },
                  },
                  '& .MuiTabs-indicator': {
                    background: 'linear-gradient(135deg, #00d4ff 0%, #0099cc 100%)',
                    height: '3px',
                            },
                  '& .MuiTabs-scrollButtons': {
                    color: '#b0b0b0',
                    '&.Mui-disabled': {
                      opacity: 0.3,
                    },
                            },
                          }}
                        >
                <Tab 
                  icon={<CodeIcon />} 
                  label="C Programming" 
                  iconPosition="start"
                />
                <Tab 
                  icon={<MemoryIcon />} 
                  label="C++ Programming" 
                  iconPosition="start"
                />
                <Tab 
                  icon={<SchoolIcon />} 
                  label="Data Structures & Algorithms" 
                  iconPosition="start"
                />
                <Tab 
                  icon={<PsychologyIcon />} 
                  label="Python" 
                  iconPosition="start"
                />
                <Tab 
                  icon={<CodeIcon />} 
                  label="DSA with Python" 
                  iconPosition="start"
                />
                <Tab 
                  icon={<DataObjectIcon />} 
                  label="Machine Learning" 
                  iconPosition="start"
                />
                <Tab 
                  icon={<CoffeeIcon />} 
                  label="Java Programming" 
                  iconPosition="start"
                />
              </Tabs>
            </Paper>
          </motion.div>

          {/* Content Sections */}
          <AnimatePresence mode="wait">
            <motion.div
              key={activeTab}
              initial={{ opacity: 0, x: 20 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: -20 }}
              transition={{ duration: 0.5 }}
            >
              {activeTab === 0 && (
                <Box>
                            <Typography
                  variant="h4"
                            sx={{
                    color: '#fff',
                    fontWeight: 700,
                    mb: 4,
                    textAlign: 'center',
                  }}
                >
                  C Programming Fundamentals
                            </Typography>
                  {renderTopics(cTopics, 'C')}
                          </Box>
              )}
              
              {activeTab === 1 && (
                <Box>
                          <Typography
                  variant="h4"
                          sx={{
                    color: '#fff',
                    fontWeight: 700,
                    mb: 4,
                    textAlign: 'center',
                  }}
                >
                  C++ Object-Oriented Programming
                          </Typography>
                  {renderTopics(cppTopics, 'C++')}
              </Box>
              )}
              
              {activeTab === 2 && (
                <Box>
                  <Typography
                    variant="h4"
                    sx={{
                      color: '#fff',
                      fontWeight: 700,
                      mb: 4,
                      textAlign: 'center',
                    }}
                  >
                    Data Structures & Algorithms
                  </Typography>
                  {renderTopics(dsaTopics, 'DSA')}
                </Box>
              )}

              {activeTab === 3 && (
                <Box>
                  <Typography
                    variant="h4"
                        sx={{
                      color: '#fff',
                      fontWeight: 700,
                      mb: 4,
                      textAlign: 'center',
                    }}
                  >
                    Python Basics
                  </Typography>
                  {renderTopics(pythonTopics, 'Python')}
                </Box>
              )}

              {activeTab === 4 && (
                <Box>
                  <Typography
                    variant="h4"
                          sx={{
                      color: '#fff',
                      fontWeight: 700,
                      mb: 4,
                      textAlign: 'center',
                    }}
                  >
                    DSA with Python
                  </Typography>
                  {renderTopics(dsaWithPythonTopics, 'DSA_Python')}
                </Box>
              )}

              {activeTab === 5 && (
                <Box>
                            <Typography
                  variant="h4"
                            sx={{
                    color: '#fff',
                    fontWeight: 700,
                    mb: 4,
                    textAlign: 'center',
                  }}
                >
                  Machine Learning Concepts
                            </Typography>
                  {renderTopics(mlTopics, 'ML')}
                          </Box>
              )}

              {activeTab === 6 && (
                <Box>
                          <Typography
                  variant="h4"
                            sx={{
                    color: '#fff',
                    fontWeight: 700,
                    mb: 4,
                    textAlign: 'center',
                  }}
                >
                  Java Programming
                            </Typography>
                  {renderTopics(javaTopics, 'Java')}
              </Box>
              )}
            </motion.div>
          </AnimatePresence>

          {/* Call to Action */}
            <motion.div
            initial={{ opacity: 0, y: 30 }}
              animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.8, delay: 0.6 }}
            >
            <Box sx={{ textAlign: 'center', mt: 8 }}>
                <Paper
                elevation={0}
                  sx={{
                  background: 'linear-gradient(135deg, rgba(0, 212, 255, 0.1) 0%, rgba(0, 153, 204, 0.1) 100%)',
                  backdropFilter: 'blur(20px)',
                  border: '1px solid rgba(0, 212, 255, 0.2)',
                    borderRadius: 3,
                  p: 4,
                }}
              >
                <Typography
                  variant="h5"
                  sx={{
                    color: '#fff',
                    fontWeight: 600,
                    mb: 2,
                  }}
                >
                    Ready to Practice?
                  </Typography>
                <Typography
                  variant="body1"
                  sx={{
                    color: '#b0b0b0',
                    mb: 3,
                  }}
                >
                  Start a new journey with our Academy
                  </Typography>
                  <Button
                    variant="contained"
                    size="large"
                    startIcon={<WhatsAppIcon />}
                    onClick={() => {
                      const phoneNumber = '919209455752';
                      const message = encodeURIComponent('Hi! I want to join Shetty Sir\'s Coding Academy. Please provide me with more information about the courses and enrollment process.');
                      const whatsappUrl = `https://wa.me/${phoneNumber}?text=${message}`;
                      window.open(whatsappUrl, '_blank');
                    }}
                    sx={{
                  background: 'linear-gradient(135deg, #25D366 0%, #128C7E 100%)',
                  borderRadius: 2,
                  px: 4,
                  py: 1.5,
                    fontWeight: 600,
                    textTransform: 'uppercase',
                    letterSpacing: '0.5px',
                    '&:hover': {
                    background: 'linear-gradient(135deg, #128C7E 0%, #075E54 100%)',
                      transform: 'translateY(-2px)',
                      boxShadow: '0 8px 25px rgba(37, 211, 102, 0.3)',
                    },
                  }}
                >
                Join Now
                </Button>
              </Paper>
            </Box>
          </motion.div>
        </Container>
      </Box>
    </motion.div>
    </>
  );
};

export default BasicsPage; 